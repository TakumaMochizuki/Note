===Question===
Ch1
* stack base, register base vm? what's different between stack and register?
* choreographics
* correctness & liveness
Ch2
* cancel(xxx)
* checked exception
* SafeAsync

===Notes===
Ch1
* Responsive 
  => Do not block the main/UI thread
  => Offload heavy tasks like networking, file I/O, image processing onto worker thread
  => Collaborate between UI and wroker threads, Concurrency!
  => Java concurrency
     => Low level mechanism: Thread, Runnable, synchronized, volatile
     => Executor, atomic wrapper classes, locking contstructs, concurrent collections
  => Cuncurrent problems
     => Correctness 
        => Problem: Race condition
        => Solution: Mutual exclusion
     => Liveness => Dead lock
  => Android concurrent problem
     => Memory leak through holding references to views, activity context at worker thread when an activity lifecycle is destoryed
     => Waste CPU cycles, battery by continuing to do background works and results cannot be displayed because an activity has finished
     => Prevent system from killing long-run operations to complete when system reclaims memory
Ch2
* AsyncTask
=> When to use it
   => Allow to perform short-lived background operations (below 3 seconds, 3 only means very short) which pertains directly to specific activity or fragment to reflect on UI views immediately
      => For example, 
         => I/O blocking: fetch data from database, read a local file
         => CPU intensive: do image processing, manipulate text string
=> When not to use it
   => Cost much effort to run (over 3 seconds) operations when device rotates, switches between activities, app...
   => Operations are not specific to current activity or fragment
      => For example, HTTP web API calls
=> Implementation of AsyncTask
   => Extend AsyncTask
      => Params are parameter objects passed in to AsyncTask
      => Progress is object which is used to report task status
      => Result is object which contains final result
   => Do heavy tasks at doInBackground method
      => Run at worker thread
      => Never called if a task is canceled before it begins
   => Interact with UI thread via overriding methods
      onPreExecute: show wait cursor 
      onProgressUpdate: update the progress of a task
      onPostExecute: hide wait cursor
      onCanceled: hide wait cursor
      => Cannot do heavy tasks because they run at UI thread
   => To cancel a task, you need to periodically check isCancel in doInBackground method especially for those API calls that consume time
   => If exceptions happen at worker thread, you need to report to UI
      => for example
         static class Result<T> {
         	private T value;
         	private Exception e;
         }
      => Catch exception at doInBackground
=> How to use it
   => Each instance can be used only once
   => Excuting sequence of tasks
      => Serial or concurrent
   => Activity lifecycle
      => To avoid wasting CPU/battery or memory leakage because a worker thread holds an activity context or view hierarchy
         => you need to check
            => if an activity is finished, then cancel a task
            => if an activity is not finished, then keep running a task
         => Use headless retained fragment, see p30, Asynchronous Android




