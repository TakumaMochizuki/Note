===Question===
Ch1
* stack base, register base vm? what's different between stack and register?
* choreographics
* synchronization: correctness & liveness
Ch3
* asynctask v.s. handlerthread
===Notes===
Ch1
* Responsive 
  => Do not block the main/UI thread
  => Offload heavy tasks like networking, file I/O, image processing onto worker thread
  => Collaborate between UI and wroker threads, Concurrency!
  => Java concurrency
     => Low level mechanism: Thread, Runnable, synchronized, volatile
     => Executor, atomic wrapper classes, locking contstructs, concurrent collections
  => Cuncurrent problems
     => Correctness 
        => Problem: Race condition
        => Solution: Mutual exclusion
     => Liveness => Dead lock
  => Android concurrent problem
     => Memory leak through holding references to views, Activity context at worker thread when an Activity lifecycle is destoryed
     => Waste CPU cycles, battery by continuing to do background works and results cannot be displayed because an Activity has finished
     => Prevent system from killing long-run operations to complete when system reclaims memory

Ch2 AsyncTask
=> When to use it
   => Allow to perform short-lived background operations (below 3 seconds, 3 only means very short) which pertains directly to specific Activity or fragment to reflect on UI views immediately
      => For example, 
         => I/O blocking: fetch data from database, read a local file
         => CPU intensive: do image processing, manipulate text string
=> When not to use it
   => Cost much effort to run (over 3 seconds) operations when device rotates, switches between activities, app...
   => Operations are not specific to current Activity or fragment and shared amount activities, fragments or in a app.
      => For example, HTTP web API calls
=> Implementation of AsyncTask
   => Extend AsyncTask
      => Params are parameter objects passed in to AsyncTask
      => Progress is object which is used to report task status
      => Result is object which contains final result
   => Don't implement it as anonymous inner class or inner class in Activity or it will result in memory leakage
   => Do heavy tasks at doInBackground method
      => Run at worker thread
      => Never called if a task is canceled before it begins
   => Interact with UI thread via overriding methods
      onPreExecute: show wait cursor 
      onProgressUpdate: update the progress of a task
      onPostExecute: hide wait cursor
      onCanceled: hide wait cursor
      => Cannot do heavy tasks because they run at UI thread
   => To cancel a task, you need to periodically check isCancel in doInBackground method especially for those API calls that consume time
   => If exceptions happen at worker thread, you need to report to UI
      => for example, implement Result as below:
         static class Result<T> {
         	private T value;
         	private Exception e;
         }
      => Catch exception at doInBackground
   => Don't keep any references to Activity context, view hierarchy of Activity in task object 
=> How to use it
   => Each task can be executed only once
   => Order of task execution
      => Serial or concurrent
   => Take care of the issue of Activity lifecycle
      => To avoid wasting CPU/battery or memory leakage because a worker thread holds an Activity context or view hierarchy
         => 1. You need to check
            => if an Activity is finished, then cancel a task
            => if an Activity is not finished, then keep running a task, for example A Activity starts another B Activity
         => 2. Use "headless retained fragment", see p30, Asynchronous Android
      => Use WeakReference to keep Activity context or view hierarchy and avoid app crash when updating UI after Activity is finished
=> Alternative
   => SafeAsyncTask<ResultT>, Roboguice
=> Criticism
   => Bind closely to Activity cycle
      => Memory leakage
         => When Activity is finished and a task is still running, memory leaks if 
            => 1. a task holds a reference to Activity context, view hierarchy of Activity
            => 2. a task is implemented as a anonymous inner class, inner class in an Activity
      => Losing results
         => When an activiy is recreated due to device rotation, results lose
      => App crash
         => If an AsycTask holds a reference to view hierarchy of Activity and updating UI for view hierarchy incurs exceptions when Activity is finished
   => Not support exception handling
=> Reference:
   => https://raw.githubusercontent.com/octo-online/robospice/master/gfx/RoboSpice-InfoGraphics.png

Ch3
=> Looper
   => Event loop
      => With an event queue
      => Dispatch events (message) in its method loop
   => Attach to a specific thread
   => Each app has a main event loop to dispatch all UI events in main thread
=> Handler
   => Schedule events (Runnable or Message) to queue in its looper
   => Respond to events in method handleMessage or Runnable callback
   => Attach to a looper
   => Cancel pending events via removeXXX
   => Event object
      => Message
         => Prefer composition (implement Handler.Callback) over inheritance (exend Handler)
         => Override handledMessage
         => Define message id
      => Runnable
         => Memory leaks when you create an anonymous inner or inner class when post a delayed event
   => You can bind a Handler to any thread and dipatch event to it
=> Event (Message or Runnable)
   => Message
      => Prefer obtaining a message via Message.obtain or Handler.obtainMessage to a new instance
         => Message class maintain a recycle list to reduce GC from a lot of message objects
      => Send it via Handler
   => Runnable
      => Post a runnable via Handler
   => When writing code in Activity, runOnUiThread is a good helper to use
   => In a single thread app, breaking down a big task into small pieces could maintain responsive
   => Message v.s. Runnable
      => Message can be reused to avoid GC
=> HandlerThread
   => When to use it
      => Allow to perform short-lived background operations (below 3 seconds, 3 only means very short) which pertains directly to specific Activity or fragment to reflect on UI views immediately
      => For example, 
         => I/O blocking: fetch data from database, read a local file
         => CPU intensive: do image processing, manipulate text string
   => Create an instance of HandlerThread, pass its Looper to a Handler and submit tasks to it
   => A HandlerThread must be shut down by invoking quit method to avoid memory leakage
      => A quitSafely to process all remaining tasks before shutting down
   => Issue when work with Activity
      => Memory leakage
         => It's not a good idea to post non-static Runnable onto the main thread's message queue especially with postDelay and postAtTime
            => Avoid non-static, annonymous class
            => Use WeakReference to keep Acitivity context and view hierarchy in Runnable
            => Add and remove UI callback at onResume, onPause respectively in UI Handler
      => App crash
         => Use WeakReference to keep Acitivity context and view hierarchy in Runnable

Ch4
=> Loader
   => Benefits
      => The heavy lifting is performed on a background thread and results are delivered to UI thread on completion
      => Loaded data can be cached and redelivered on repeat calls
         => Cache across Activity restart
         => Cache before a specific Activity is destroyed, A -> B -> C, 
      => Loader's data is bound to a specific UI/Activity lifecycle
         => Loader is managed by LoaderManager
         => Each Activity has its own LoaderManager which manages its Loaders
      => Monitor data source and reload when necessary
   => Managed object and is looked after by LoaderManager
      => Created when LoaderManager.initLoader, LoaderManager.restartLoader are called
      => Destroyed when LoaderManager.destroyLoader is called or Activity is destroyed
   => AsyncTaskLoader
      => General purpose Loader
      => Extend Loader and is Abstract class to be extended
      => Use AsyncTask to perform background jobs
         => Tasks are executed using THREAD_POOL_EXECUTOR
      => Do heavy tasks in loadInBackground at background thread
      => A diagram to show the relationship among client, LoaderManager, Loader
         => (Todo: Add a diagram here)
   => CursorLoader
      => Extend AsyncTaskLoader
      => Load data from local database
=> LoaderManager
   => Coordinate Loader's lifecycle events with UI/Activity/Fragment lifecycle and expose Loader to its client
      => Dispatch a heavy task to Loader
      => Provide callbacks to its client to respond to data loaded by Loader
   => Connect a Loader with its client via LoaderCallbacks
      => onCreateLoader: create a Loader which is managed by LoaderManager
      => onLoadFinished: receive results and bind data to UI
      => onLoaderReset: unbind data to UI
   => Operation
      => Call initLoader/restartLoader to start a Loader task
         => Use id to identify a specific Loader
            => Use a string and hash it as a unique id
               => "Image_Loader".hashCode()
         => Use Bundle to contain parameters
         => Use LoaderCallbacks to interact with UI
      => Call destroyLoader to destroy a Loader task
=> Compare to AsyncTask
   => Pros
      => Cache data to across Activity restart
      => LoaderManager manages lifecycle of Loader
   => Cons
      => More code to write